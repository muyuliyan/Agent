import requests
import torch
import torch.nn as nn
import numpy as np
from sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from zhipuai import ZhipuAI

# 这里假设一些简单的标识用于模拟判断隐私、实时信息等情况，实际需完善逻辑
PRIVACY_KEYWORDS = ["电话", "姓名", "家庭住址"]
VEHICLE_INFO_KEYWORDS = ["电量", "油量", "车内操作"]

# 模拟简单的数据集，实际可替换为真实的学习数据集
DATASET = []


# 提取文本特征的函数（使用词袋模型 + TF-IDF）
def extract_text_features(question):
    vectorizer = CountVectorizer(min_df=0.3,max_df=1.0,max_features=1,ngram_range=(1,2))
    word_count_matrix = vectorizer.fit_transform([question])
    print('词袋模型处理后的词计数矩阵维度：',word_count_matrix.shape)
    tfidf_transformer = TfidfTransformer()
    tfidf_matrix = tfidf_transformer.fit_transform(word_count_matrix)
    print('TF-IDF 转换后的矩阵维度：',tfidf_matrix.shape)
    features = tfidf_matrix.toarray().flatten()
    return features


# 策略网络定义
class PolicyNetwork(nn.Module):
    def __init__(self, input_size, output_size):
        super(PolicyNetwork, self).__init__()
        self.fc1 = nn.Linear(1, 128)
        print('self.fc1权重维度：',self.fc1.weight.shape)
        self.fc2 = nn.Linear(128, output_size)
        print('self.fc2权重维度：',self.fc2.weight.shape)

    def forward(self, x):
        print('输入x的维度：',x.shape)
        x = torch.relu(self.fc1(x))
        x = torch.softmax(self.fc2(x), dim=1)
        return x


class IntelligentDrivingAgent:
    def __init__(self):
        self.dataset = DATASET
        self.scheduling_strategy = self.build_scheduling_strategy()
        # 此处根据新的特征提取方式，假设一个合适的输入特征大小（这里设为100，可按需调整）
        self.policy_network = PolicyNetwork(1, 3)  
        self.optimizer = torch.optim.Adam(self.policy_network.parameters(), lr=0.001)
        self.epsilon = 0.1  # 探索概率
        self.small_reward = 0  # 用于奖励塑造的小奖励累计值

    def build_scheduling_strategy(self):
        def strategy(question):
            if np.random.random() < self.epsilon:
                return np.random.choice(["端侧", "云侧", "跨端云"])  # 随机探索新动作
            state = torch.FloatTensor(extract_text_features(question)).unsqueeze(0)
            action_probs = self.policy_network(state)
            actions = ["端侧", "云侧", "跨端云"]
            return actions[torch.multinomial(action_probs, 1).item()]
        return strategy

    def build_intent_classifier(self):
        def classify(question):
            if any(keyword in question for keyword in PRIVACY_KEYWORDS):
                return "privacy"
            elif any(keyword in question for keyword in VEHICLE_INFO_KEYWORDS):
                return "vehicle_info"
            return "other"
        return classify

    def build_lower_level_agent(self):
        # 这里假设是一个简单的基于Q-learning的底层代理，实际要更复杂完善
        class LowerLevelAgent:
            def __init__(self):
                self.q_table = {}

            def get_action(self, state):
                if state not in self.q_table:
                    self.q_table[state] = {"端侧": 0, "云侧": 0, "跨端云": 0}
                return max(self.q_table[state], key=self.q_table[state].get)

        return LowerLevelAgent()

    def learn_from_dataset(self):
        # 模拟基于数据集学习的简单逻辑，实际要复杂得多
        for data in self.dataset:
            # 这里可添加具体学习更新逻辑，比如更新模型参数等
            pass

    def update_policy(self, question, reward):
        state = torch.FloatTensor(extract_text_features(question)).unsqueeze(0)
        action_probs = self.policy_network(state)
        action = torch.multinomial(action_probs, 1).item()  # 根据概率选动作
        log_prob = torch.log(action_probs[0][action])
        loss = -log_prob * reward  # 策略梯度计算损失
        self.optimizer.zero_grad()
        loss.backward()
        self.optimizer.step()

    def call_external_tool(self, tool_name, params):
        # 模拟调用外部工具逻辑，实际按对应API等要求实现
        print(f"调用外部工具 {tool_name}，参数：{params}")
        return "模拟工具调用结果"

    def process_question(self, question):
        self.learn_from_dataset()
        intent = self.build_intent_classifier()(question)
        state = extract_text_features(question)
        if intent == "privacy":
            location = self.build_lower_level_agent().get_action(state)
        elif intent == "vehicle_info":
            location = "云侧"  # 简单规则判断车辆信息走云侧
        else:
            location = self.scheduling_strategy(question)

        if location == "端侧":
            answer = self.call_end_side_model(question)
        elif location == "云侧":
            answer = self.call_cloud_side_model(question)
        else:
            answer = self.call_cross_models(question)

        # 假设简单根据回答中是否包含特定关键词判断用户是否满意，实际要更科学评估
        if "满意" in answer:
            reward = 1
        else:
            reward = -1
        self.update_policy(question, reward)
        return answer

    def call_end_side_model(self, question):
        # 这里调用月之暗面模型（按你提供的相关代码进行调整）
        api_key = "sk-MRUzE4gHSBZRJ8bIsVWfmnjv0nl8aR5EXTQayhCxKyPfAY1I"
        api_endpoint = "https://api.moonshot.cn/v1/chat/completions"
        headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": "moonshot-v1-8k",
            "messages": [
                {"role": "system", "content": "你是一个帮助智能驾驶场景答疑的助手，任务是提供专业准确的回答。"},
                {"role": "user", "content": question}
            ],
            "max_tokens": 100,
            "temperature": 0.5
        }
        try:
            response = requests.post(api_endpoint, headers=headers, json=data)
            if response.status_code == 200:
                response_data = response.json()
                return response_data['choices'][0]['message']['content']
            else:
                print(f"Error: {response.status_code}")
                print(response.text)
                return "模型调用出现错误，请稍后再试"
        except Exception as e:
            print(f"An error occurred: {e}")
            return "模型调用出现异常，请检查网络等情况"

    def call_cloud_side_model(self, question):
        # 这里调用智谱模型（按你提供的相关代码进行调整）
        api_key = "8b35bd0e8485274929df27077dc5ce88.5L31oDzUClISrU0g"
        client = ZhipuAI(
            api_key=api_key,
            base_url='https://open.bigmodel.cn/api/paas/v4/'
        )
        try:
            completion = client.chat.completions.create(
                model="glm-4-flash",
                messages=[
                    {"role": "system", "content": "你是一个帮助智能驾驶场景答疑的助手，任务是提供专业准确的回答。"},
                    {"role": "user", "content": question}
                ],
                max_tokens=100,
                temperature=0.5
            )
            return completion.choices[0].message.content
        except Exception as e:
            print(f"An error occurred: {e}")
            return "模型调用出现异常，请检查网络等情况"

    def call_cross_models(self, question):
        # 模拟跨端云调用逻辑，实际可能涉及复杂的协作交互
        end_side_result = self.call_end_side_model(question)
        cloud_side_result = self.call_cloud_side_model(question)
        # 这里可添加整合两边结果的逻辑，示例简单拼接
        return f"整合结果：端侧回答为{end_side_result}，云侧回答为{cloud_side_result}"


if __name__ == "__main__":
    agent = IntelligentDrivingAgent()
    while True:  # 设置循环，可多次接收用户输入
        question = input("请输入你的智能驾驶相关问题（输入 'exit' 可退出）：")  # 获取用户输入
        if question.lower() == "exit":  # 判断是否输入退出指令
            break
        answer = agent.process_question(question)
        print(answer)

    


